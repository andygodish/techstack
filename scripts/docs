#!/usr/bin/env bash

# docs - Dynamic file collector for documentation
# Usage: ./docs [OPTIONS]

set -e

# Default values
SOURCE_DIR=""
OUTPUT_DIR="./notebook-upload"
FILE_EXTENSIONS="md"
REPO_PREFIX=""
RECURSIVE=true
OVERWRITE=false
VERBOSE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Help function
show_help() {
    cat << EOF
Dynamic File Collector - Collect documentation files with flexible extensions

USAGE:
    ./docs -s SOURCE_DIR [OPTIONS]

REQUIRED:
    -s, --source DIR        Source directory to collect files from

OPTIONS:
    -o, --output DIR        Output directory (default: ./notebook-upload)
    -e, --extensions EXT    Comma-separated file extensions (default: md)
    -p, --prefix NAME       Prefix for renamed files (default: directory name)
    -r, --recursive         Search recursively (default: true)
    -R, --no-recursive      Disable recursive search
    --overwrite             Overwrite existing files in output directory
    -v, --verbose           Verbose output
    -h, --help              Show this help

EXAMPLES:
    # Collect all .md files from docs directory
    ./docs -s ./docs

    # Collect .md and .mdx files with custom prefix
    ./docs -s ./my-app/docs -e "md,mdx" -p "myapp"

    # Non-recursive search for specific extensions
    ./docs -s ./guides -e "txt,rst,md" -R

    # Verbose output with custom output directory
    ./docs -s ./documentation -o ./temp-upload -v

SUPPORTED EXTENSIONS:
    Common documentation formats: md, mdx, txt, rst, adoc, org
    Any extension can be specified with -e flag
EOF
}

# Logging functions
log_info() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Function to sanitize filename (remove special characters)
sanitize_filename() {
    local filename="$1"
    echo "$filename" | sed 's|/|-|g' | sed 's/[^a-zA-Z0-9.-]/_/g'
}

# Function to get relative path from source directory
get_relative_path() {
    local file_path="$1"
    local source_dir="$2"
    echo "${file_path#$source_dir/}"
}

# Function to generate unique filename to avoid conflicts
generate_filename() {
    local source_file="$1"
    local source_dir="$2"
    local prefix="$3"
    
    local relative_path=$(get_relative_path "$source_file" "$source_dir")
    local filename=$(basename "$relative_path")
    local dir_path=$(dirname "$relative_path")
    
    if [[ "$dir_path" == "." ]]; then
        # File is in root of source directory
        echo "${prefix}-${filename}"
    else
        # Include directory structure in filename
        local sanitized_dir=$(sanitize_filename "$dir_path")
        echo "${prefix}-${sanitized_dir}-${filename}"
    fi
}

# Function to find files with specified extensions
find_files() {
    local source_dir="$1"
    local extensions="$2"
    local recursive="$3"
    
    IFS=',' read -ra ext_array <<< "$extensions"
    
    for ext in "${ext_array[@]}"; do
        ext=$(echo "$ext" | xargs) # trim whitespace
        if [[ "$recursive" == true ]]; then
            find "$source_dir" -type f -name "*.$ext" 2>/dev/null
        else
            find "$source_dir" -maxdepth 1 -type f -name "*.$ext" 2>/dev/null
        fi
    done | sort -u
}

# Function to copy files
copy_files() {
    local source_dir="$1"
    local output_dir="$2"
    local prefix="$3"
    local extensions="$4"
    local recursive="$5"
    
    log_info "Searching for files with extensions: $extensions"
    log_info "Source directory: $source_dir"
    log_info "Output directory: $output_dir"
    log_info "Recursive search: $recursive"
    
    # Create output directory if it doesn't exist
    mkdir -p "$output_dir"
    
    # Find all matching files and store in array
    local files=()
    while IFS= read -r file; do
        if [[ -n "$file" ]]; then
            files+=("$file")
        fi
    done < <(find_files "$source_dir" "$extensions" "$recursive")
    
    if [[ ${#files[@]} -eq 0 ]]; then
        log_warning "No files found with extensions: $extensions"
        return 0
    fi
    
    log_info "Found ${#files[@]} file(s)"
    
    local copied_count=0
    local skipped_count=0
    
    # Process each file
    for file in "${files[@]}"; do
        log_info "Processing file: $file"
        
        if [[ ! -f "$file" ]]; then
            log_info "File not found, skipping: $file"
            continue
        fi
        
        local new_filename=$(generate_filename "$file" "$source_dir" "$prefix")
        local output_path="$output_dir/$new_filename"
        
        log_info "Generated filename: $new_filename"
        
        # Check if file already exists
        if [[ -f "$output_path" && "$OVERWRITE" == false ]]; then
            log_warning "File already exists, skipping: $new_filename"
            skipped_count=$((skipped_count + 1))
            continue
        fi
        
        # Copy file
        log_info "Copying: $file -> $output_path"
        if cp "$file" "$output_path"; then
            log_success "Copied: $(get_relative_path "$file" "$source_dir") â†’ $new_filename"
            copied_count=$((copied_count + 1))
        else
            log_error "Failed to copy: $file"
            return 1
        fi
    done
    
    echo
    echo "=== SUMMARY ==="
    echo "Files copied: $copied_count"
    echo "Files skipped: $skipped_count"
    echo "Output directory: $output_dir"
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--source)
                SOURCE_DIR="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -e|--extensions)
                FILE_EXTENSIONS="$2"
                shift 2
                ;;
            -p|--prefix)
                REPO_PREFIX="$2"
                shift 2
                ;;
            -r|--recursive)
                RECURSIVE=true
                shift
                ;;
            -R|--no-recursive)
                RECURSIVE=false
                shift
                ;;
            --overwrite)
                OVERWRITE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use -h or --help for usage information."
                exit 1
                ;;
        esac
    done
}

# Validate arguments
validate_arguments() {
    if [[ -z "$SOURCE_DIR" ]]; then
        log_error "Source directory is required. Use -s or --source flag."
        echo "Use -h or --help for usage information."
        exit 1
    fi
    
    if [[ ! -d "$SOURCE_DIR" ]]; then
        log_error "Source directory does not exist: $SOURCE_DIR"
        exit 1
    fi
    
    # Set default prefix if not provided
    if [[ -z "$REPO_PREFIX" ]]; then
        REPO_PREFIX=$(basename "$(realpath "$SOURCE_DIR")")
        log_info "Using default prefix: $REPO_PREFIX"
    fi
}

# Main function
main() {
    echo "Dynamic File Collector"
    echo "======================"
    
    parse_arguments "$@"
    validate_arguments
    
    copy_files "$SOURCE_DIR" "$OUTPUT_DIR" "$REPO_PREFIX" "$FILE_EXTENSIONS" "$RECURSIVE"
    
    echo
    log_success "Collection complete! Files are ready in: $OUTPUT_DIR"
}

# Run main function with all arguments
main "$@"